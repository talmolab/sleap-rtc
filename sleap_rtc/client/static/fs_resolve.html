<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLEAP-RTC Video Path Resolution</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Outfit:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a24;
            --bg-hover: #22222e;
            --border-color: #2a2a3a;
            --border-highlight: #3d3d52;
            --text-primary: #e8e8f0;
            --text-secondary: #9090a8;
            --text-muted: #606078;
            --accent-primary: #6366f1;
            --accent-secondary: #818cf8;
            --accent-glow: rgba(99, 102, 241, 0.15);
            --success: #22c55e;
            --success-glow: rgba(34, 197, 94, 0.15);
            --warning: #f59e0b;
            --warning-glow: rgba(245, 158, 11, 0.15);
            --error: #ef4444;
            --error-glow: rgba(239, 68, 68, 0.15);
            --folder-color: #fbbf24;
            --file-slp: #a78bfa;
            --file-video: #38bdf8;
            --file-model: #f472b6;
            --file-default: #9090a8;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.5;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem 1.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo {
            font-weight: 600;
            font-size: 1.25rem;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .connection-badge {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.375rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .connection-badge.connected {
            background: var(--success-glow);
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .connection-badge.connected::before {
            content: '';
            width: 8px;
            height: 8px;
            background: var(--success);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .connection-badge.disconnected {
            background: var(--error-glow);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: var(--error);
        }

        .connection-badge.disconnected::before {
            content: '';
            width: 8px;
            height: 8px;
            background: var(--error);
            border-radius: 50%;
        }

        .connection-badge.connecting {
            background: var(--warning-glow);
            border: 1px solid rgba(245, 158, 11, 0.3);
            color: var(--warning);
        }

        .connection-badge.connecting::before {
            content: '';
            width: 8px;
            height: 8px;
            background: var(--warning);
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .slp-info {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
            padding: 0.25rem 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Main content */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Left panel - Video list */
        .video-panel {
            width: 350px;
            min-width: 280px;
            max-width: 500px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .video-panel-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .video-panel-title {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .video-count {
            font-size: 0.75rem;
            color: var(--text-secondary);
            padding: 0.25rem 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        .video-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .video-item {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s ease;
            margin-bottom: 0.25rem;
        }

        .video-item:hover {
            background: var(--bg-hover);
        }

        .video-item.selected {
            background: var(--accent-glow);
            border: 1px solid rgba(99, 102, 241, 0.3);
        }

        .video-item.resolved {
            opacity: 0.7;
        }

        .video-status {
            flex-shrink: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }

        .video-status.missing {
            color: var(--error);
        }

        .video-status.resolved {
            color: var(--success);
        }

        .video-status.auto-resolved {
            color: var(--warning);
        }

        .video-info {
            flex: 1;
            min-width: 0;
        }

        .video-filename {
            font-weight: 500;
            font-size: 0.85rem;
            color: var(--text-primary);
            word-break: break-word;
        }

        .video-original-path {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
            word-break: break-all;
        }

        .video-resolved-path {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--success);
            margin-top: 0.25rem;
            word-break: break-all;
        }

        .video-auto-badge {
            display: inline-block;
            font-size: 0.65rem;
            padding: 0.125rem 0.375rem;
            background: var(--warning-glow);
            color: var(--warning);
            border-radius: 4px;
            margin-left: 0.5rem;
        }

        /* Resize handle */
        .resize-handle {
            width: 4px;
            cursor: col-resize;
            background: transparent;
            transition: background 0.15s ease;
        }

        .resize-handle:hover {
            background: var(--accent-primary);
        }

        /* Right panel - File browser */
        .browser-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .browser-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .browser-title {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .browser-hint {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Mount points sidebar */
        .browser-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .mount-sidebar {
            width: 200px;
            background: var(--bg-tertiary);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 0.5rem;
        }

        .mount-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s ease;
            font-size: 0.85rem;
        }

        .mount-item:hover {
            background: var(--bg-hover);
        }

        .mount-item.active {
            background: var(--accent-glow);
            border: 1px solid rgba(99, 102, 241, 0.3);
        }

        .mount-icon {
            width: 16px;
            height: 16px;
            color: var(--folder-color);
        }

        /* File grid */
        .file-browser {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .file-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 0.75rem;
        }

        .file-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.75rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s ease;
            text-align: center;
        }

        .file-item:hover {
            background: var(--bg-hover);
        }

        .file-item.selected {
            background: var(--accent-glow);
            border: 1px solid rgba(99, 102, 241, 0.3);
        }

        .file-icon {
            width: 40px;
            height: 40px;
            margin-bottom: 0.5rem;
        }

        .file-name {
            font-size: 0.75rem;
            word-break: break-word;
            max-width: 100%;
        }

        .file-size {
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        /* Breadcrumb */
        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.8rem;
            overflow-x: auto;
        }

        .breadcrumb-item {
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: background 0.15s ease;
            white-space: nowrap;
        }

        .breadcrumb-item:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .breadcrumb-item.current {
            color: var(--text-primary);
            font-weight: 500;
        }

        .breadcrumb-separator {
            color: var(--text-muted);
        }

        /* Action bar */
        .action-bar {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 1rem 1.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .action-bar-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .resolution-status {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .resolution-status .count {
            font-weight: 600;
            color: var(--text-primary);
        }

        .resolution-status .resolved {
            color: var(--success);
        }

        .resolution-status .missing {
            color: var(--error);
        }

        .action-bar-right {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            border: none;
            font-family: inherit;
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--bg-hover);
            border-color: var(--border-highlight);
        }

        .btn-primary {
            background: var(--accent-primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-secondary);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Loading state */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: var(--text-secondary);
            gap: 1rem;
        }

        .spinner {
            width: 32px;
            height: 32px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Empty state */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: var(--text-secondary);
            text-align: center;
        }

        .empty-icon {
            width: 64px;
            height: 64px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .empty-title {
            font-weight: 500;
            font-size: 1rem;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .empty-desc {
            font-size: 0.85rem;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 5rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            padding: 0.75rem 1.25rem;
            border-radius: 8px;
            font-size: 0.85rem;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-color: rgba(34, 197, 94, 0.3);
            background: var(--success-glow);
        }

        .toast.error {
            border-color: rgba(239, 68, 68, 0.3);
            background: var(--error-glow);
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 500px;
            width: 90%;
        }

        .modal-title {
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 0.75rem;
        }

        .modal-body {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--border-highlight);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-left">
            <div class="logo">SLEAP-RTC</div>
            <div id="connectionBadge" class="connection-badge connecting">
                <span id="connectionStatus">Connecting...</span>
            </div>
            <div id="slpInfo" class="slp-info">Loading SLP info...</div>
        </div>
    </header>

    <!-- Main content -->
    <main class="main-content">
        <!-- Left panel - Video list -->
        <aside class="video-panel" id="videoPanel">
            <div class="video-panel-header">
                <span class="video-panel-title">Missing Videos</span>
                <span id="videoCount" class="video-count">0 / 0</span>
            </div>
            <div class="video-list" id="videoList">
                <div class="loading">
                    <div class="spinner"></div>
                    Loading video data...
                </div>
            </div>
        </aside>

        <!-- Resize handle -->
        <div class="resize-handle" id="resizeHandle"></div>

        <!-- Right panel - File browser -->
        <section class="browser-panel">
            <div class="browser-header">
                <span class="browser-title">Locate Video Files</span>
                <span class="browser-hint">Select a video file to resolve paths. Other videos in the same directory will be auto-detected.</span>
            </div>
            <div class="browser-content">
                <nav class="mount-sidebar" id="mountSidebar">
                    <div class="loading">
                        <div class="spinner"></div>
                    </div>
                </nav>
                <div class="file-browser-wrapper" style="flex: 1; display: flex; flex-direction: column; overflow: hidden;">
                    <div class="breadcrumb" id="breadcrumb"></div>
                    <div class="file-browser" id="fileBrowser">
                        <div class="empty-state">
                            <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                            </svg>
                            <div class="empty-title">Select a Mount Point</div>
                            <div class="empty-desc">Choose a location from the sidebar to browse files.</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- Action bar -->
    <footer class="action-bar">
        <div class="action-bar-left">
            <div class="resolution-status">
                <span class="count resolved" id="resolvedCount">0</span> resolved,
                <span class="count missing" id="missingCount">0</span> missing
            </div>
        </div>
        <div class="action-bar-right">
            <button class="btn btn-secondary" onclick="cancelResolution()">Cancel</button>
            <button class="btn btn-primary" id="saveBtn" onclick="saveResolution()" disabled>Save Corrected SLP</button>
        </div>
    </footer>

    <!-- Toast -->
    <div class="toast" id="toast">
        <span id="toastMessage"></span>
    </div>

    <!-- Confirmation Modal -->
    <div class="modal-overlay" id="confirmModal">
        <div class="modal">
            <div class="modal-title" id="modalTitle">Confirm Save</div>
            <div class="modal-body" id="modalBody">
                Some videos are still missing. Save anyway?
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmSave()">Save Anyway</button>
            </div>
        </div>
    </div>

    <!-- Output Directory Modal -->
    <div class="modal-overlay" id="outputDirModal">
        <div class="modal">
            <div class="modal-title">Select Output Directory</div>
            <div class="modal-body">
                The corrected SLP file will be saved to:
                <div id="outputDirPath" style="font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; margin-top: 0.5rem; padding: 0.5rem; background: var(--bg-tertiary); border-radius: 4px; word-break: break-all;"></div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeOutputDirModal()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmOutputDir()">Save Here</button>
            </div>
        </div>
    </div>

    <script>
        // State
        let ws = null;
        let mounts = [];
        let currentPath = '';
        let currentEntries = [];
        let selectedVideoIndex = null;
        let selectedBrowserFile = null;

        // Video resolution state
        let slpPath = '';
        let missingVideos = []; // [{filename, original_path, resolved_path, auto_resolved}]
        let filenameMap = {}; // {original_path -> resolved_path}

        // Pending output directory for save
        let pendingOutputDir = '';

        // Get token from URL
        function getToken() {
            const params = new URLSearchParams(window.location.search);
            return params.get('token');
        }

        // Utility functions
        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
            return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
        }

        function getFileExtension(filename) {
            const parts = filename.split('.');
            return parts.length > 1 ? parts[parts.length - 1].toLowerCase() : '';
        }

        function getFilename(path) {
            return path.split('/').pop() || path.split('\\').pop() || path;
        }

        function getDirectory(path) {
            const parts = path.split('/');
            parts.pop();
            return parts.join('/') || '/';
        }

        function isVideoFile(filename) {
            const ext = getFileExtension(filename);
            return ['mp4', 'avi', 'mov', 'mkv', 'wmv', 'flv', 'webm'].includes(ext);
        }

        // WebSocket connection
        function connectWebSocket() {
            const token = getToken();
            if (!token) {
                showToast('Missing authentication token', 'error');
                return;
            }

            const wsUrl = `ws://localhost:${window.location.port}/ws?token=${token}`;
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                updateConnectionStatus('connected', 'Connected');
                // Request video check data
                ws.send(JSON.stringify({ type: 'get_video_check' }));
            };

            ws.onclose = () => {
                updateConnectionStatus('disconnected', 'Disconnected');
                setTimeout(connectWebSocket, 3000);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateConnectionStatus('disconnected', 'Connection Error');
            };

            ws.onmessage = (event) => {
                handleMessage(JSON.parse(event.data));
            };
        }

        function updateConnectionStatus(status, text) {
            const badge = document.getElementById('connectionBadge');
            const statusText = document.getElementById('connectionStatus');
            badge.className = 'connection-badge ' + status;
            statusText.textContent = text;
        }

        function handleMessage(msg) {
            switch (msg.type) {
                case 'video_check_response':
                    handleVideoCheckResponse(msg.data);
                    break;

                case 'mounts':
                    mounts = msg.data;
                    renderMountSidebar();
                    break;

                case 'list_response':
                    currentEntries = msg.data.entries || [];
                    renderFileBrowser();
                    break;

                case 'scan_dir_response':
                    handleScanDirResponse(msg.data);
                    break;

                case 'write_slp_ok':
                    handleWriteSlpOk(msg.data);
                    break;

                case 'write_slp_error':
                    handleWriteSlpError(msg.data);
                    break;

                case 'error':
                    showToast(`Error: ${msg.message}`, 'error');
                    break;

                case 'connection_lost':
                    updateConnectionStatus('disconnected', 'Worker Disconnected');
                    showToast('Worker connection lost', 'error');
                    break;
            }
        }

        // Video check response handler
        function handleVideoCheckResponse(data) {
            slpPath = data.slp_path || '';
            document.getElementById('slpInfo').textContent = slpPath ? getFilename(slpPath) : 'Unknown SLP';

            // Initialize missing videos list
            missingVideos = (data.missing || []).map(v => ({
                filename: v.filename,
                original_path: v.original_path,
                resolved_path: null,
                auto_resolved: false
            }));

            renderVideoList();
            updateResolutionStatus();
        }

        // Render video list
        function renderVideoList() {
            const container = document.getElementById('videoList');

            if (missingVideos.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                            <polyline points="22 4 12 14.01 9 11.01"/>
                        </svg>
                        <div class="empty-title">All Videos Accessible</div>
                        <div class="empty-desc">No missing video paths to resolve.</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = missingVideos.map((video, index) => {
                const isResolved = video.resolved_path !== null;
                const isSelected = selectedVideoIndex === index;
                const statusClass = isResolved ? (video.auto_resolved ? 'auto-resolved' : 'resolved') : 'missing';
                const statusIcon = isResolved ? (video.auto_resolved ? '~' : '&#10003;') : '&#10007;';

                return `
                    <div class="video-item ${isSelected ? 'selected' : ''} ${isResolved ? 'resolved' : ''}"
                         onclick="selectVideo(${index})">
                        <div class="video-status ${statusClass}">${statusIcon}</div>
                        <div class="video-info">
                            <div class="video-filename">
                                ${video.filename}
                                ${video.auto_resolved ? '<span class="video-auto-badge">auto</span>' : ''}
                            </div>
                            <div class="video-original-path">${video.original_path}</div>
                            ${video.resolved_path ? `<div class="video-resolved-path">${video.resolved_path}</div>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            // Update count
            const resolved = missingVideos.filter(v => v.resolved_path !== null).length;
            document.getElementById('videoCount').textContent = `${resolved} / ${missingVideos.length}`;
        }

        function selectVideo(index) {
            selectedVideoIndex = index;
            renderVideoList();
        }

        // Render mount sidebar
        function renderMountSidebar() {
            const container = document.getElementById('mountSidebar');

            if (mounts.length === 0) {
                container.innerHTML = `
                    <div class="empty-state" style="padding: 1rem;">
                        <div class="empty-desc">No mounts available</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = mounts.map(mount => {
                const isActive = currentPath.startsWith(mount.path);
                return `
                    <div class="mount-item ${isActive ? 'active' : ''}" onclick="selectMount('${mount.path}')">
                        <svg class="mount-icon" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M10 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"/>
                        </svg>
                        <span>${mount.label || mount.path}</span>
                    </div>
                `;
            }).join('');
        }

        function selectMount(path) {
            currentPath = path;
            selectedBrowserFile = null;
            requestListDir(path);
            renderMountSidebar();
        }

        // Request directory listing
        function requestListDir(path) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                document.getElementById('fileBrowser').innerHTML = '<div class="loading"><div class="spinner"></div>Loading...</div>';
                ws.send(JSON.stringify({
                    type: 'list_dir',
                    path: path,
                    offset: 0
                }));
            }
        }

        // Render file browser
        function renderFileBrowser() {
            renderBreadcrumb();

            const container = document.getElementById('fileBrowser');

            if (currentEntries.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                        </svg>
                        <div class="empty-title">Empty Directory</div>
                        <div class="empty-desc">This directory contains no files.</div>
                    </div>
                `;
                return;
            }

            const items = currentEntries.map(entry => {
                const itemPath = currentPath + '/' + entry.name;
                const isSelected = selectedBrowserFile === itemPath;
                const ext = getFileExtension(entry.name);
                const isVideo = isVideoFile(entry.name);
                const isDir = entry.type === 'directory';

                let iconColor = 'var(--file-default)';
                if (isDir) iconColor = 'var(--folder-color)';
                else if (isVideo) iconColor = 'var(--file-video)';

                const iconSvg = isDir
                    ? `<svg class="file-icon" style="color: ${iconColor}" viewBox="0 0 24 24" fill="currentColor">
                           <path d="M10 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"/>
                       </svg>`
                    : `<svg class="file-icon" style="color: ${iconColor}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                           <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                           <polyline points="14 2 14 8 20 8"/>
                           ${isVideo ? '<polygon points="10 9 16 12 10 15"/>' : ''}
                       </svg>`;

                return `
                    <div class="file-item ${isSelected ? 'selected' : ''}"
                         onclick="${isDir ? `navigateTo('${itemPath}')` : `selectBrowserFile('${itemPath}')`}"
                         ondblclick="${isDir ? `navigateTo('${itemPath}')` : `resolveWithFile('${itemPath}')`}">
                        ${iconSvg}
                        <div class="file-name">${entry.name}</div>
                        <div class="file-size">${isDir ? 'Folder' : formatSize(entry.size || 0)}</div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `<div class="file-grid">${items}</div>`;
        }

        function renderBreadcrumb() {
            const container = document.getElementById('breadcrumb');
            if (!currentPath) {
                container.innerHTML = '';
                return;
            }

            const parts = currentPath.split('/').filter(p => p);
            let pathAccum = '';

            const crumbs = parts.map((part, i) => {
                pathAccum += '/' + part;
                const isLast = i === parts.length - 1;
                const path = pathAccum;
                return `
                    <span class="breadcrumb-item ${isLast ? 'current' : ''}" onclick="navigateTo('${path}')">${part}</span>
                    ${isLast ? '' : '<span class="breadcrumb-separator">/</span>'}
                `;
            }).join('');

            container.innerHTML = crumbs;
        }

        function navigateTo(path) {
            currentPath = path;
            selectedBrowserFile = null;
            requestListDir(path);
            renderMountSidebar();
        }

        function selectBrowserFile(path) {
            selectedBrowserFile = path;
            renderFileBrowser();
        }

        // Resolve video with selected file
        function resolveWithFile(filePath) {
            if (selectedVideoIndex === null || selectedVideoIndex >= missingVideos.length) {
                showToast('Select a missing video first', 'error');
                return;
            }

            const video = missingVideos[selectedVideoIndex];
            video.resolved_path = filePath;
            video.auto_resolved = false;
            filenameMap[video.original_path] = filePath;

            // Trigger directory scan for other missing videos
            const directory = getDirectory(filePath);
            const unresolvedFilenames = missingVideos
                .filter(v => v.resolved_path === null)
                .map(v => v.filename);

            if (unresolvedFilenames.length > 0 && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'scan_dir',
                    directory: directory,
                    filenames: unresolvedFilenames
                }));
            }

            renderVideoList();
            updateResolutionStatus();

            // Auto-select next unresolved video
            const nextUnresolved = missingVideos.findIndex(v => v.resolved_path === null);
            if (nextUnresolved !== -1) {
                selectedVideoIndex = nextUnresolved;
                renderVideoList();
            }
        }

        // Handle directory scan response
        function handleScanDirResponse(data) {
            const found = data.found || {};
            let autoResolvedCount = 0;

            for (const video of missingVideos) {
                if (video.resolved_path === null && found[video.filename]) {
                    video.resolved_path = found[video.filename];
                    video.auto_resolved = true;
                    filenameMap[video.original_path] = found[video.filename];
                    autoResolvedCount++;
                }
            }

            if (autoResolvedCount > 0) {
                showToast(`Auto-resolved ${autoResolvedCount} video(s)`, 'success');
                renderVideoList();
                updateResolutionStatus();
            }
        }

        // Update resolution status
        function updateResolutionStatus() {
            const resolved = missingVideos.filter(v => v.resolved_path !== null).length;
            const missing = missingVideos.length - resolved;

            document.getElementById('resolvedCount').textContent = resolved;
            document.getElementById('missingCount').textContent = missing;

            // Enable save button if at least one is resolved
            document.getElementById('saveBtn').disabled = resolved === 0;
        }

        // Save resolution
        function saveResolution() {
            const resolved = missingVideos.filter(v => v.resolved_path !== null).length;
            const missing = missingVideos.length - resolved;

            if (missing > 0) {
                document.getElementById('modalTitle').textContent = 'Unresolved Videos';
                document.getElementById('modalBody').textContent =
                    `${missing} video(s) are still missing. The saved SLP file will have incomplete video paths. Continue anyway?`;
                document.getElementById('confirmModal').classList.add('show');
            } else {
                promptOutputDir();
            }
        }

        function closeModal() {
            document.getElementById('confirmModal').classList.remove('show');
        }

        function confirmSave() {
            closeModal();
            promptOutputDir();
        }

        function promptOutputDir() {
            // Use directory of original SLP as default output
            pendingOutputDir = getDirectory(slpPath) || currentPath || (mounts[0] ? mounts[0].path : '');
            document.getElementById('outputDirPath').textContent = pendingOutputDir;
            document.getElementById('outputDirModal').classList.add('show');
        }

        function closeOutputDirModal() {
            document.getElementById('outputDirModal').classList.remove('show');
        }

        function confirmOutputDir() {
            closeOutputDirModal();

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'write_slp',
                    slp_path: slpPath,
                    output_dir: pendingOutputDir,
                    filename_map: filenameMap
                }));
                showToast('Saving corrected SLP file...', 'success');
            }
        }

        function handleWriteSlpOk(data) {
            showToast(`Saved to: ${getFilename(data.output_path)}`, 'success');

            // Show success modal or close window
            document.getElementById('modalTitle').textContent = 'Success!';
            document.getElementById('modalBody').innerHTML = `
                Corrected SLP file saved to:<br>
                <code style="font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; word-break: break-all;">${data.output_path}</code>
                <br><br>
                ${data.videos_updated} video path(s) updated.
            `;
            document.querySelector('#confirmModal .modal-actions').innerHTML = `
                <button class="btn btn-primary" onclick="closeModal()">Done</button>
            `;
            document.getElementById('confirmModal').classList.add('show');
        }

        function handleWriteSlpError(data) {
            showToast(`Error: ${data.error}`, 'error');
        }

        function cancelResolution() {
            if (confirm('Cancel video path resolution? No changes will be saved.')) {
                window.close();
            }
        }

        function showToast(message, type = '') {
            const toast = document.getElementById('toast');
            toast.className = 'toast' + (type ? ' ' + type : '');
            document.getElementById('toastMessage').textContent = message;
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Panel resize
        let isResizing = false;
        let startX = 0;
        let startWidth = 0;

        document.getElementById('resizeHandle').addEventListener('mousedown', (e) => {
            isResizing = true;
            startX = e.clientX;
            startWidth = document.getElementById('videoPanel').offsetWidth;
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const diff = e.clientX - startX;
            const newWidth = Math.min(Math.max(startWidth + diff, 280), 500);
            document.getElementById('videoPanel').style.width = newWidth + 'px';
        });

        document.addEventListener('mouseup', () => {
            isResizing = false;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        });

        // Initialize
        connectWebSocket();
    </script>
</body>
</html>
